

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>pcnaDeep.refiner &mdash; pcnaDeep 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> pcnaDeep
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules/index.html">API Documentation</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pcnaDeep</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>pcnaDeep.refiner</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pcnaDeep.refiner</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>
<span class="kn">import</span> <span class="nn">skimage.morphology</span> <span class="k">as</span> <span class="nn">morph</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">RobustScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">pcnaDeep.data.utils</span> <span class="kn">import</span> <span class="n">get_outlier</span><span class="p">,</span> <span class="n">deduce_transition</span>
<span class="kn">from</span> <span class="nn">pcnaDeep.resolver</span> <span class="kn">import</span> <span class="n">get_rsv_input_gt</span>
<span class="kn">import</span> <span class="nn">tqdm</span>


<div class="viewcode-block" id="dist"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.dist">[docs]</a><span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate distance of a set of coordinates</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="nb">float</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Refiner"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner">[docs]</a><span class="k">class</span> <span class="nc">Refiner</span><span class="p">:</span>

<div class="viewcode-block" id="Refiner.__init__"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxBG</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">minM</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;SVM&#39;</span><span class="p">,</span>
                 <span class="n">threshold_mt_F</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">threshold_mt_T</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span>
                 <span class="n">search_range</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sample_freq</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">model_train</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">dilate_factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">aso_trh</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dist_weight</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">svm_c</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">dt_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">test_id</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Refinement of the tracked objects.</span>

<span class="sd">        Algorithms:</span>
<span class="sd">            1. Smooth classification by convolution of the confidence score</span>
<span class="sd">            2. Register track information, temporal and spatial. Additionally, classification within certain range will</span>
<span class="sd">               be used as feature for recognizing parent-daughter relationship.</span>

<span class="sd">        Args:</span>
<span class="sd">            track (pandas.DataFrame): tracked object table.</span>
<span class="sd">            smooth (int): smoothing window on classification confidence.</span>
<span class="sd">            maxBG (float): Maximum appearance of other phases when searching mitosis.</span>
<span class="sd">            minM (float): Minimum appearance of mitosis.</span>
<span class="sd">            mode (str): how to resolve parent-daughter relationship, either &#39;SVM&#39;, &#39;TRAIN&#39; or &#39;TRH&#39;.</span>
<span class="sd">            - Essential for TRH mode:</span>
<span class="sd">            threshold_mt_F (int): mitosis displace maximum, can be evaluated as maximum cytokinesis distance.</span>
<span class="sd">            threshold_mt_T (int): mitosis frame difference maximum, can be evaluated as maximum mitosis frame length.</span>
<span class="sd">            - Essential for SVM/TRAIN mode (for normalizing different imaging conditions):</span>
<span class="sd">            search_range (int): when calculating mitosis score, how many time points to consider. </span>
<span class="sd">                Any track length shorter than search_range will not be considered during mitosis association.</span>
<span class="sd">            sample_freq (float): sampling frequency: x frame per minute.</span>
<span class="sd">            model_train (str): path to SVM model training data.</span>
<span class="sd">            mask (numpy.ndarray): object masks, same shape as input, must labeled with object ID.</span>
<span class="sd">            dilate_factor (float): dilate the mask with `n * mean object radius`, default 0.5.</span>
<span class="sd">            dist_weight (float): 0~1, distance weight in calculating cost in TRH mode *only*</span>
<span class="sd">            svm_c (int): SVM C parameter, higher stricter.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;pcna.Refiner&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metaData</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sample_freq&#39;</span><span class="p">:</span> <span class="n">sample_freq</span><span class="p">,</span>
                         <span class="s1">&#39;meanDisplace&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getMeanDisplace</span><span class="p">()[</span><span class="s1">&#39;mean_displace&#39;</span><span class="p">])}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metaData</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SEARCH_RANGE</span> <span class="o">=</span> <span class="n">search_range</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;SVM&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;TRAIN&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;TRAIN_GT&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SVM_PATH</span> <span class="o">=</span> <span class="n">model_train</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;TRH&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">FRAME_MT_TOLERANCE</span> <span class="o">=</span> <span class="n">threshold_mt_T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">DIST_MT_TOLERANCE</span> <span class="o">=</span> <span class="n">threshold_mt_F</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Mode can only be SVM, TRAIN or TRH, for SVM-mitosis resolver, &#39;</span>
                             <span class="s1">&#39;training of the resolver or threshold based resolver.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dt_id</span> <span class="o">=</span> <span class="n">dt_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">test_id</span> <span class="o">=</span> <span class="n">test_id</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span> <span class="o">=</span> <span class="n">smooth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">DO_AUG</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SVM_C</span> <span class="o">=</span> <span class="n">svm_c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ASO_TRH</span> <span class="o">=</span> <span class="n">aso_trh</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">==</span> <span class="s1">&#39;TRH&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ASO_TRH</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dilate_factor</span> <span class="o">=</span> <span class="n">dilate_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MAX_BG</span> <span class="o">=</span> <span class="n">maxBG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MIN_M</span> <span class="o">=</span> <span class="n">minM</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">short_tracks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daug_from_broken</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_mt_mask</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {parent ID: (exit frame, quality)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mt_entry_lookup</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># {daughter ID: (exit frame, quality)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imprecise</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># imprecise mitosis: daughter exit without M classification</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[[</span><span class="s1">&#39;major_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis&#39;</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[[</span><span class="s1">&#39;mean_intensity&#39;</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Mean size: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_weight</span> <span class="o">=</span> <span class="n">dist_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ann</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">,</span> <span class="s1">&#39;app_frame&#39;</span><span class="p">,</span> <span class="s1">&#39;disapp_frame&#39;</span><span class="p">,</span> <span class="s1">&#39;app_x&#39;</span><span class="p">,</span> <span class="s1">&#39;app_y&#39;</span><span class="p">,</span> <span class="s1">&#39;disapp_x&#39;</span><span class="p">,</span> <span class="s1">&#39;disapp_y&#39;</span><span class="p">,</span> <span class="s1">&#39;app_stage&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;disapp_stage&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_parent&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="Refiner.break_mitosis"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.break_mitosis">[docs]</a>    <span class="k">def</span> <span class="nf">break_mitosis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Break mitosis tracks; iterate until no track is broken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cur_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">track</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">])</span>
        <span class="n">filtered_track</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">track</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">trk</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">])):</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trk</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">trk</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">filtered_track</span> <span class="o">=</span> <span class="n">filtered_track</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">continue</span>

            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">MAX_BG</span> <span class="ow">and</span> <span class="s1">&#39;M&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">]):</span>
                <span class="bp">cls</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">confid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sub</span><span class="p">[[</span><span class="s1">&#39;Probability of G1/G2&#39;</span><span class="p">,</span> <span class="s1">&#39;Probability of S&#39;</span><span class="p">,</span> <span class="s1">&#39;Probability of M&#39;</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;parentTrackId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">prev_exit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;parentTrackId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="s1">&#39;daug&#39;</span><span class="p">][</span><span class="n">trk</span><span class="p">][</span><span class="s1">&#39;m_exit&#39;</span><span class="p">]</span>
                    <span class="n">esp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">prev_exit</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">esp</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">deduce_transition</span><span class="p">(</span><span class="n">l</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="n">tar</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">confid</span><span class="p">,</span> <span class="n">min_tar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MIN_M</span><span class="p">,</span> <span class="n">max_res</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MAX_BG</span><span class="p">,</span>
                                        <span class="n">escape</span><span class="o">=</span><span class="n">esp</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">esp</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">cur_m_entry</span><span class="p">,</span> <span class="n">m_exit</span> <span class="o">=</span> <span class="n">out</span>
                    <span class="n">cla</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_m_entry</span><span class="p">,</span> <span class="n">m_exit</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">cla</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span>
                    
                    <span class="n">sub</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cla</span>
                    <span class="c1"># split mitosis track, keep parent track with 2 &#39;M&#39; prediction</span>
                    <span class="c1"># this makes cytokinesis unpredictable...</span>
                    <span class="n">m_entry</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])[</span><span class="n">cur_m_entry</span><span class="p">]</span>
                    <span class="n">x_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cur_m_entry</span><span class="p">:</span><span class="n">m_exit</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">y_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cur_m_entry</span><span class="p">:</span><span class="n">m_exit</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">frame_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
                    <span class="n">distance</span> <span class="o">=</span> \
                        <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">dist</span><span class="p">(</span><span class="n">x_list</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">y_list</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                               <span class="n">x_list</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_list</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">frame_list</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">frame_list</span><span class="p">[</span><span class="n">x</span><span class="p">]),</span>
                                 <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_list</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
                    <span class="n">sp_time</span> <span class="o">=</span> <span class="n">cur_m_entry</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                    <span class="n">new_track</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">frame_list</span><span class="p">[</span><span class="n">sp_time</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">new_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_max</span>
                    <span class="n">new_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;lineageId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;lineageId&#39;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># inherit the lineage</span>
                    <span class="n">new_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;parentTrackId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trk</span>  <span class="c1"># mitosis parent asigned</span>
                    <span class="c1"># register to the class</span>
                    <span class="n">x1</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sp_time</span><span class="p">][</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span>
                    <span class="n">y1</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sp_time</span><span class="p">][</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sp_time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span>
                    <span class="n">y2</span> <span class="o">=</span> <span class="n">sub</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">sp_time</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">trk</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;div&#39;</span><span class="p">:</span> <span class="n">m_entry</span><span class="p">,</span>
                                        <span class="s1">&#39;daug&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">cur_max</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;m_exit&#39;</span><span class="p">:</span> <span class="n">frame_list</span><span class="p">[</span><span class="n">m_exit</span><span class="p">],</span> 
                                            <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">),</span> <span class="mi">2</span><span class="p">)}}}</span>
                    <span class="n">cur_max</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">old_track</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">frame_list</span><span class="p">[</span><span class="n">sp_time</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">filtered_track</span> <span class="o">=</span> <span class="n">filtered_track</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_track</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">filtered_track</span> <span class="o">=</span> <span class="n">filtered_track</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_track</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">filtered_track</span> <span class="o">=</span> <span class="n">filtered_track</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Found mitosis track: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">filtered_track</span><span class="p">,</span> <span class="n">count</span></div>

<div class="viewcode-block" id="Refiner.register_track"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.register_track">[docs]</a>    <span class="k">def</span> <span class="nf">register_track</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register track annotation table </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frame_tolerance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SEARCH_RANGE</span>

        <span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># annotation table: record appearance and disappearance information of the track</span>
        <span class="n">track_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]))</span>
        <span class="n">ann</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;track&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;app_frame&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;disapp_frame&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;app_x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>  <span class="c1"># appearance coordinate</span>
               <span class="s2">&quot;app_y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;disapp_x&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>  <span class="c1"># disappearance coordinate</span>
               <span class="s2">&quot;disapp_y&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;app_stage&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>  <span class="c1"># cell cycle classification at appearance</span>
               <span class="s2">&quot;disapp_stage&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>  <span class="c1"># cell cycle classification at disappearance</span>
               <span class="s2">&quot;mitosis_parent&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>  <span class="c1"># mitotic parent track to predict</span>
               <span class="s2">&quot;mitosis_daughter&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;m_entry&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;m_exit&quot;</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)],</span>
               <span class="s2">&quot;mitosis_identity&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">)]</span>
               <span class="p">}</span>

        <span class="n">short_tracks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">track_count</span><span class="p">):</span>
            <span class="n">cur_track</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="c1"># constraint A: track &lt; 2 frame length tolerance is filtered out, No relationship can be deduced from that.</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># (dis-)appearance time</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;app_frame&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;disapp_frame&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
            <span class="c1"># (dis-)appearance coordinate</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;app_x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;app_y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;disapp_x&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cur_track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;disapp_y&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">cur_track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">render_emerging</span><span class="p">(</span><span class="n">track</span><span class="o">=</span><span class="n">cur_track</span><span class="p">,</span> <span class="n">cov_range</span><span class="o">=</span><span class="n">frame_tolerance</span><span class="p">)</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;app_stage&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ann</span><span class="p">[</span><span class="s1">&#39;disapp_stage&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">frame_tolerance</span><span class="p">:</span>
                <span class="n">short_tracks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">trks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">short_tracks</span> <span class="o">=</span> <span class="n">short_tracks</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">ann</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span>
        <span class="c1"># register mitosis relationship from break_mitosis()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">daug_trk</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># parent</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ann</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="s1">&#39;parent&#39;</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;mitosis_daughter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">daug_trk</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;m_entry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;div&#39;</span><span class="p">]</span>

            <span class="c1"># daughter</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">ann</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daug_trk</span><span class="p">]</span><span class="o">.</span><span class="n">index</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="s1">&#39;daughter&#39;</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;mitosis_parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;m_exit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">][</span><span class="n">daug_trk</span><span class="p">][</span><span class="s1">&#39;m_exit&#39;</span><span class="p">]</span>

        <span class="n">track</span><span class="p">[</span><span class="s1">&#39;lineageId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># erase original lineage ID, assign in following steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;High quality tracks subjected to predict relationship: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">short_tracks</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">track</span><span class="p">,</span> <span class="n">short_tracks</span><span class="p">,</span> <span class="n">ann</span></div>

<div class="viewcode-block" id="Refiner.render_emerging"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.render_emerging">[docs]</a>    <span class="k">def</span> <span class="nf">render_emerging</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">cov_range</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Render emerging phase</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cov_range</span><span class="p">:</span>
            <span class="n">bg_cls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cov_range</span><span class="p">])</span>
            <span class="n">bg_emg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;emerging&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cov_range</span><span class="p">])</span>
            <span class="n">end_cls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cov_range</span><span class="p">):</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">end_emg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;emerging&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[(</span><span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cov_range</span><span class="p">):</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bg_cls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">cov_range</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="n">bg_emg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;emerging&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">min</span><span class="p">(</span><span class="n">cov_range</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>
            <span class="n">end_cls</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cov_range</span><span class="p">):])</span>
            <span class="n">end_emg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;emerging&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">cov_range</span><span class="p">):])</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bg_emg</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">bg_emg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bg_cls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_cls</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">end_emg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end_cls</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;M&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bg_cls</span><span class="p">),</span> <span class="s1">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">end_cls</span><span class="p">)</span></div>

<div class="viewcode-block" id="Refiner.revert"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.revert">[docs]</a>    <span class="k">def</span> <span class="nf">revert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span><span class="p">,</span> <span class="n">parentId</span><span class="p">,</span> <span class="n">daughterId</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove information of a relationship registered to ann and mt_dic</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Revert: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">parentId</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">daughterId</span><span class="p">))</span>
        <span class="c1"># parent</span>
        <span class="n">mt_dic</span><span class="p">[</span><span class="n">parentId</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">daughterId</span><span class="p">)</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">][</span><span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/parent&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">,</span> <span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ori</span>
        <span class="n">ori_daug</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">][</span><span class="s1">&#39;mitosis_daughter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ori_daug</span> <span class="o">=</span> <span class="n">ori_daug</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
        <span class="n">ori_daug</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">daughterId</span><span class="p">))</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">,</span> <span class="s1">&#39;mitosis_daughter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ori_daug</span><span class="p">)</span>
        <span class="c1"># daughter</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">][</span><span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;/daughter&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s1">&#39;mitosis_identity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ori</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s1">&#39;m_exit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s1">&#39;mitosis_parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">parentId</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">mt_dic</span><span class="p">[</span><span class="n">parentId</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span></div>

<div class="viewcode-block" id="Refiner.register_mitosis"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.register_mitosis">[docs]</a>    <span class="k">def</span> <span class="nf">register_mitosis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span><span class="p">,</span> <span class="n">parentId</span><span class="p">,</span> <span class="n">daughterId</span><span class="p">,</span> <span class="n">m_exit</span><span class="p">,</span> <span class="n">dist_dif</span><span class="p">,</span> <span class="n">m_entry</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register parent and dduahgter information to ann and mt_dic</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Register: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">parentId</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">daughterId</span><span class="p">))</span>
        <span class="n">ori</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">,</span> <span class="s2">&quot;mitosis_daughter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ori_idt</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">,</span> <span class="s2">&quot;mitosis_identity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s2">&quot;mitosis_identity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s2">&quot;mitosis_identity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="s2">&quot;/daughter&quot;</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s2">&quot;m_exit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_exit</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughterId</span><span class="p">,</span> <span class="s2">&quot;mitosis_parent&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parentId</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">,</span> <span class="s2">&quot;mitosis_daughter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ori</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">daughterId</span><span class="p">)</span>
        <span class="n">ann</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parentId</span><span class="p">,</span> <span class="s2">&quot;mitosis_identity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ori_idt</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/parent&#39;</span>
        <span class="k">if</span> <span class="n">parentId</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">mt_dic</span><span class="p">[</span><span class="n">parentId</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;div&#39;</span><span class="p">:</span> <span class="n">m_entry</span><span class="p">,</span> <span class="s1">&#39;daug&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="n">mt_dic</span><span class="p">[</span><span class="n">parentId</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">][</span><span class="n">daughterId</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;m_exit&#39;</span><span class="p">:</span> <span class="n">m_exit</span><span class="p">,</span> <span class="s1">&#39;dist&#39;</span><span class="p">:</span> <span class="n">dist_dif</span><span class="p">}</span>
        <span class="k">return</span> <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span></div>

<div class="viewcode-block" id="Refiner.getMtransition"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.getMtransition">[docs]</a>    <span class="k">def</span> <span class="nf">getMtransition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trackId</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;entry&#39;</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get mitosis transition time by trackId</span>

<span class="sd">        Args:</span>
<span class="sd">            trackId (int): track ID</span>
<span class="sd">            direction (str): either &#39;entry&#39; or &#39;exit&#39;, mitosis entry or exit</span>
<span class="sd">            skip (int): escape frames from `deduce_transition` method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">skp</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">trk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trackId</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trk</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">])</span>
        <span class="n">c1_confid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trk</span><span class="p">[[</span><span class="s1">&#39;Probability of G1/G2&#39;</span><span class="p">,</span> <span class="s1">&#39;Probability of S&#39;</span><span class="p">,</span> <span class="s1">&#39;Probability of M&#39;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;exit&#39;</span><span class="p">:</span>
            <span class="n">daug_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trackId</span><span class="p">][</span><span class="s1">&#39;m_entry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">daug_entry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trk</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">daug_entry</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">c1</span><span class="p">[:</span><span class="n">skp</span><span class="p">]</span>
                <span class="n">c1_confid</span> <span class="o">=</span> <span class="n">c1_confid</span><span class="p">[:</span><span class="n">skp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">deduce_transition</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">tar</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">c1_confid</span><span class="p">,</span> <span class="n">min_tar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_res</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MAX_BG</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="n">skip</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;entry&#39;</span><span class="p">:</span>
            <span class="n">par_exit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trackId</span><span class="p">][</span><span class="s1">&#39;m_exit&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">par_exit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">skp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trk</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">par_exit</span><span class="p">)</span>
                <span class="n">c1</span> <span class="o">=</span> <span class="n">c1</span><span class="p">[</span><span class="n">skp</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">c1_confid</span> <span class="o">=</span> <span class="n">c1_confid</span><span class="p">[</span><span class="n">skp</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">deduce_transition</span><span class="p">(</span><span class="n">c1</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">tar</span><span class="o">=</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="n">confidence</span><span class="o">=</span><span class="n">c1_confid</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                                      <span class="n">min_tar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_res</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">MAX_BG</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="n">skip</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">trans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">trans</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Direction can either be entry or exit&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">skp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;entry&#39;</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trk</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])[</span><span class="n">trans</span> <span class="o">+</span> <span class="n">skp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">trk</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])[</span><span class="n">trans</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">trans</span></div>

<div class="viewcode-block" id="Refiner.extract_pools"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.extract_pools">[docs]</a>    <span class="k">def</span> <span class="nf">extract_pools</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extra_par</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_daug</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract potential parent and daughter pool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">daughter_pool</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">parent_pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">daughter_pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daug_from_broken</span> <span class="o">=</span> <span class="n">daughter_pool</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]))</span>
        <span class="n">lin_par_pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;parentTrackId&#39;</span><span class="p">]))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">parent_pool</span><span class="p">))</span>
        <span class="n">lin_daug_pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;parentTrackId&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">][</span><span class="s1">&#39;trackId&#39;</span><span class="p">]))</span> <span class="o">-</span>
                             <span class="nb">set</span><span class="p">(</span><span class="n">daughter_pool</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parent_pool</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lin_par_pool</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">short_tracks</span><span class="p">:</span>
                <span class="c1"># wild parents: at least two M classification at the end</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="s1">&#39;disapp_stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">parent_pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">daughter_pool</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lin_daug_pool</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">short_tracks</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="s1">&#39;app_stage&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># if re.search(&#39;S&#39;, self.ann[self.ann[&#39;track&#39;] == i][&#39;app_stage&#39;].values[0]) is None:</span>
                    <span class="n">daughter_pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extra_par</span><span class="p">:</span>
            <span class="n">parent_pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">parent_pool</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">extra_par</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">extra_daug</span><span class="p">:</span>
            <span class="n">daughter_pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">daughter_pool</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">extra_daug</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">parent_pool</span><span class="p">,</span> <span class="n">daughter_pool</span></div>

<div class="viewcode-block" id="Refiner.get_parent_mask"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.get_parent_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_parent_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract parent mask, begin from mitosis entry, end with parent disappearance</span>

<span class="sd">        Args:</span>
<span class="sd">            p (int): parent track ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_mt_mask</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mt_entry_lookup</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">))]</span>
            <span class="n">lbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;continuous_label&#39;</span><span class="p">])</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">])</span>
            <span class="n">sls</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lbs</span><span class="p">)):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">frame</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">sl</span> <span class="o">!=</span> <span class="n">lbs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="n">sl</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
                <span class="n">sls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">sls</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            <span class="c1"># dilate the mask by 50% mean radius, adjustable</span>
            <span class="n">dilate_range</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dilate_factor</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_size</span><span class="o">/</span><span class="mi">4</span><span class="p">)))</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">morph</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">selem</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dilate_range</span><span class="p">,</span> <span class="n">dilate_range</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Object not found in mask for parent: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; in frames: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">frame</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">par_mt_mask</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            import skimage.io as io</span>
<span class="sd">            from skimage.util import img_as_ubyte</span>
<span class="sd">            to_save = img_as_ubyte(out)</span>
<span class="sd">            io.imsave(&#39;../../test/test_files/mask/&#39;+str(p)+&#39;.tif&#39;, to_save)</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_mt_mask</span><span class="p">[</span><span class="n">p</span><span class="p">]</span></div>

<div class="viewcode-block" id="Refiner.daug_app_in_par_mask"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.daug_app_in_par_mask">[docs]</a>    <span class="k">def</span> <span class="nf">daug_app_in_par_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">daug</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if daughter appears in the mask of parent</span>

<span class="sd">        Args:</span>
<span class="sd">            par (int): parent track ID</span>
<span class="sd">            daug (int): daughter track ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_mask</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daug</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;app_x&#39;</span><span class="p">]))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">sub</span><span class="p">[</span><span class="s1">&#39;app_y&#39;</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Refiner.extract_features"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.extract_features">[docs]</a>    <span class="k">def</span> <span class="nf">extract_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">par_pool</span><span class="p">,</span> <span class="n">daug_pool</span><span class="p">,</span> <span class="n">remove_outlier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract Input Features for the classifier</span>

<span class="sd">        Args:</span>
<span class="sd">            par_pool (list): Parent pool.</span>
<span class="sd">            daug_pool (list): Daughter pool.</span>
<span class="sd">            remove_outlier (list[int]): Remove outlier of columns in the feature map.</span>
<span class="sd">            normalize (bool): Normalize each column.</span>
<span class="sd">            sample (numpy.ndarray): Training mode only, supply positive sample information, will add y as 2nd output.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">!=</span> <span class="s1">&#39;TRAIN&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">!=</span> <span class="s1">&#39;TRAIN_GT&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only allowed to input sample in TRAIN mode.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Extracting features...&#39;</span><span class="p">)</span>
        <span class="n">ipts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sample_id</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">par_pool</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daug_pool</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getAsoInput</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="n">rgd</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># first register input from broken pairs</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">ipts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                            <span class="n">sample_id</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                            <span class="n">rgd</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">par_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="s1">&#39;disapp_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">daug_appear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">[</span><span class="s1">&#39;track&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">]][</span><span class="s1">&#39;app_frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">rgd</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">par_end</span> <span class="o">&gt;=</span> <span class="n">daug_appear</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">rgd</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">daug_app_in_par_mask</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                                <span class="k">continue</span>
                        <span class="n">ipts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                        <span class="n">sample_id</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

                    <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">daug_pool</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="n">sp_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">sp_index</span><span class="p">:</span>
                            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ipts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ipts</span><span class="p">)</span>
        <span class="n">sample_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remove_outlier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">get_outlier</span><span class="p">(</span><span class="n">ipts</span><span class="p">,</span> <span class="n">col_ids</span><span class="o">=</span><span class="n">remove_outlier</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outs</span><span class="p">]</span>
            <span class="n">ipts</span> <span class="o">=</span> <span class="n">ipts</span><span class="p">[</span><span class="n">idx</span><span class="p">,]</span>
            <span class="n">sample_id</span> <span class="o">=</span> <span class="n">sample_id</span><span class="p">[</span><span class="n">idx</span><span class="p">,]</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">,]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Removed outliers, remaining: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
            <span class="n">ipts</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">ipts</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished feature extraction: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; samples.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ipts</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_id</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ipts</span><span class="p">,</span> <span class="n">sample_id</span></div>

<div class="viewcode-block" id="Refiner.plainPredict"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.plainPredict">[docs]</a>    <span class="k">def</span> <span class="nf">plainPredict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ipts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate cost of each potential daughter-parent pair (sample).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">WEIGHT_DIST</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ASO_TRH</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dist_weight</span>
        <span class="n">WEIGHT_TIME</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ASO_TRH</span> <span class="o">-</span> <span class="n">WEIGHT_DIST</span>

        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">ipts_norm</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">ipts</span><span class="p">)</span>

        <span class="n">frame_tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FRAME_MT_TOLERANCE</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">metaData</span><span class="p">[</span><span class="s1">&#39;sample_freq&#39;</span><span class="p">]</span>
        <span class="n">dist_tol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIST_MT_TOLERANCE</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_size</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span>
                                             <span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">metaData</span><span class="p">[</span><span class="s1">&#39;meanDisplace&#39;</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">ipts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ipts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dist_tol</span> <span class="ow">or</span> <span class="n">ipts</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">frame_tol</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">WEIGHT_DIST</span> <span class="o">*</span> <span class="n">ipts_norm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">WEIGHT_TIME</span> <span class="o">*</span> <span class="n">ipts_norm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="n">score</span>
            <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Refiner.extract_train_from_break"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.extract_train_from_break">[docs]</a>    <span class="k">def</span> <span class="nf">extract_train_from_break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_id</span><span class="p">,</span> <span class="n">ipts</span><span class="p">,</span> <span class="n">mt_dic</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extract broken mitosis information to train model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sample</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sample_id</span><span class="p">)</span>
        <span class="n">sample</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;par&#39;</span><span class="p">,</span> <span class="s1">&#39;daug&#39;</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">par</span><span class="p">,</span> <span class="n">daug</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[(</span><span class="n">sample</span><span class="p">[</span><span class="s1">&#39;par&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">par</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daug</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Positive mitosis instance (parent-daughter) &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">par</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">daug</span><span class="p">)</span> <span class="o">+</span>
                              <span class="s1">&#39; filtered out; your gating may be too strict.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ipts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Refiner.associate"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.associate">[docs]</a>    <span class="k">def</span> <span class="nf">associate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Main algorithm to associate parent and daughter relationship.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ann</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">)</span>
        <span class="n">track</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">)</span>
        <span class="n">mt_dic</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">)</span>

        <span class="n">parent_pool</span><span class="p">,</span> <span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_pools</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Short tracks excluded: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">short_tracks</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Candidate parents: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">parent_pool</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Candidate daughters: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pool</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">ipts</span><span class="p">,</span> <span class="n">sample_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_features</span><span class="p">(</span><span class="n">parent_pool</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">remove_outlier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;No potential daughters found.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">track</span><span class="p">,</span> <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;SVM&#39;</span><span class="p">:</span>
            <span class="c1"># Read in baseline training data</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SVM_PATH</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>
            <span class="n">baseline_x</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ipts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">baseline_y</span> <span class="o">=</span> <span class="n">baseline</span><span class="p">[:,</span> <span class="n">baseline</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Augment SVM train: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DO_AUG</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">DO_AUG</span><span class="p">:</span>
                <span class="c1"># Train model further with already broken tracks</span>
                <span class="n">ipts_brk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_train_from_break</span><span class="p">(</span><span class="n">sample_id</span><span class="p">,</span> <span class="n">ipts</span><span class="p">,</span> <span class="n">mt_dic</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ipts_brk</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="c1"># Merge baseline and broken data</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ipts_brk</span><span class="p">,</span> <span class="n">baseline_x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">y</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">baseline_y</span><span class="p">))</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">baseline_x</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">baseline_y</span>

            <span class="c1"># Render training set to inspect</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            import os</span>
<span class="sd">            root_save = os.path.join(&#39;D:\Chan Lab\Jeff Experiments\SVM_data&#39;, self.dt_id)</span>
<span class="sd">            if self.DO_AUG:</span>
<span class="sd">                from_new = [1 for _ in range(ipts_brk.shape[0])] + [0 for _ in range(baseline.shape[0])]</span>
<span class="sd">                save_train = np.concatenate((X, np.expand_dims(y, axis=1), np.expand_dims(from_new, axis=1)), axis=1)</span>
<span class="sd">            else:</span>
<span class="sd">                save_train = np.concatenate((X, np.expand_dims(y, axis=1)), axis=1)</span>
<span class="sd">            pd.DataFrame(save_train).to_csv(os.path.join(root_save, self.test_id+&#39;_test_train.csv&#39;), index=False)</span>
<span class="sd">            &#39;&#39;&#39;</span>

            <span class="c1"># Normalize</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fitting SVM with rbf kernal, C=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SVM_C</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; gamma=&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">SVM_C</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">class_weight</span><span class="o">=</span><span class="s1">&#39;balanced&#39;</span><span class="p">)</span>

            <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">RobustScaler</span><span class="p">()</span>
            <span class="n">ipts_norm</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">ipts</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">ipts_norm</span><span class="p">)</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            # Render res and output prediction</span>
<span class="sd">            save_ipts = np.concatenate((ipts, np.expand_dims(np.argmax(res, axis=1), axis=1)), axis=1)</span>
<span class="sd">            pd.DataFrame(save_ipts).to_csv(&#39;../../test/test_res.csv&#39;, index=False, header=False)</span>
<span class="sd">            &#39;&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plainPredict</span><span class="p">(</span><span class="n">ipts</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Finished prediction.&#39;</span><span class="p">)</span>

        <span class="n">parent_pool</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample_id</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="n">cost_r_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">parent_pool</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
        <span class="n">cost_c_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">sample_id</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">cost_r_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cost_c_idx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cost</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sample_id</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cost_r_idx</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cost</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">cost_r_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cost_c_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sample_id</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">cost_c_idx</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="n">sp_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">sp_index</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cost_r_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> \
                                <span class="n">cost_c_idx</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">cost_r_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">sp_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # Save input for debugging</span>
<span class="sd">        save_cost = pd.DataFrame(cost.copy())</span>
<span class="sd">        save_cost.index = cost_r_idx</span>
<span class="sd">        save_cost.columns = cost_c_idx</span>
<span class="sd">        save_cost.to_csv(&#39;../../test/test_cost.csv&#39;)</span>
<span class="sd">        pd.DataFrame(np.concatenate((ipts, sample_id, np.expand_dims(np.argmax(res, axis=1), axis=1)),</span>
<span class="sd">                                    axis=1)).to_csv(&#39;../../test/test_input.csv&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>

        <span class="n">to_register</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row_ind</span><span class="p">)):</span>
            <span class="n">cst</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">row_ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">col_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">cst</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">ASO_TRH</span><span class="p">:</span>
                <span class="n">par</span> <span class="o">=</span> <span class="n">cost_r_idx</span><span class="p">[</span><span class="n">row_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">daug</span> <span class="o">=</span> <span class="n">cost_c_idx</span><span class="p">[</span><span class="n">col_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">par</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_register</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">to_register</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="n">daug</span><span class="p">],</span> <span class="p">[</span><span class="n">cst</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_register</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">daug</span><span class="p">)</span>
                    <span class="n">to_register</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cst</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Parent-Daughter relation to register&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">to_register</span><span class="p">)</span>

        <span class="c1"># check original mt_dic, if not in to_register, revert the relation</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">par</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_register</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">ori_daugs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">ori_daug</span> <span class="ow">in</span> <span class="n">ori_daugs</span><span class="p">:</span>
                    <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ann</span><span class="p">),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">),</span> <span class="n">par</span><span class="p">,</span> <span class="n">ori_daug</span><span class="p">)</span>

        <span class="n">ips_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">to_register</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">daugs</span><span class="p">,</span> <span class="n">csts</span> <span class="o">=</span> <span class="n">to_register</span><span class="p">[</span><span class="n">par</span><span class="p">]</span>
            <span class="n">m_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_entry_lookup</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_entry_lookup</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">imprecise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
                <span class="n">ips_count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">par</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daugs</span><span class="p">)):</span>
                    <span class="n">m_exit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span><span class="p">[</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span><span class="p">[</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">imprecise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="n">ips_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_mitosis</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ann</span><span class="p">),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">),</span>
                                                        <span class="n">par</span><span class="p">,</span> <span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m_exit</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">csts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span> <span class="n">m_entry</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ori_daugs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">for</span> <span class="n">ori_daug</span> <span class="ow">in</span> <span class="n">ori_daugs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">ori_daug</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">daugs</span><span class="p">:</span>
                        <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">revert</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ann</span><span class="p">),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">),</span> <span class="n">par</span><span class="p">,</span> <span class="n">ori_daug</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">daugs</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ori_daugs</span><span class="p">:</span>
                        <span class="n">m_exit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span><span class="p">[</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span><span class="p">[</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">imprecise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                            <span class="n">ips_count</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_mitosis</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ann</span><span class="p">),</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">),</span>
                                                            <span class="n">par</span><span class="p">,</span> <span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m_exit</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">csts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span> <span class="n">m_entry</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mt_dic</span><span class="p">[</span><span class="n">par</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">][</span><span class="n">daugs</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;dist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">csts</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># count 2 daughters-found relationships</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mt_dic</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Parent-Daughter-Daughter mitosis relations found: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Parent-Daughter mitosis relations found: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">-</span> <span class="n">count</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Imprecise tracks involved in prediction: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ips_count</span><span class="p">))</span>
        <span class="n">track</span> <span class="o">=</span> <span class="n">track</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lineageId&#39;</span><span class="p">,</span> <span class="s1">&#39;trackId&#39;</span><span class="p">,</span> <span class="s1">&#39;frame&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">track</span><span class="p">,</span> <span class="n">ann</span><span class="p">,</span> <span class="n">mt_dic</span></div>

<div class="viewcode-block" id="Refiner.update_table_with_mt"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.update_table_with_mt">[docs]</a>    <span class="k">def</span> <span class="nf">update_table_with_mt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update tracked object table with information in self.mt_dic (mitosis lookup dict).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">trk</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">lin</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trk</span><span class="p">][</span><span class="s1">&#39;lineageId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dic</span><span class="p">[</span><span class="n">trk</span><span class="p">][</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">track</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">,</span> <span class="s1">&#39;parentTrackId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trk</span>
                <span class="n">track</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;lineageId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">,</span> <span class="s1">&#39;lineageId&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lin</span>

        <span class="k">return</span> <span class="n">track</span></div>

<div class="viewcode-block" id="Refiner.smooth_track"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.smooth_track">[docs]</a>    <span class="k">def</span> <span class="nf">smooth_track</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-assign cell cycle classification based on smoothed confidence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No smoothing on object classification.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Smoothing window must be positive odd number, not &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span><span class="o">%</span><span class="mi">2</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Even smoothing window found, use the biggest odd smaller than &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;G1/G2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;M&#39;</span><span class="p">}</span>
        <span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">track_filtered</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">track</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">flt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span><span class="p">)</span>
        <span class="n">escape</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]):</span>
            <span class="n">cur_track</span> <span class="o">=</span> <span class="n">track</span><span class="p">[</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cur_track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span><span class="p">:</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Probability of S&#39;</span><span class="p">],</span> <span class="n">flt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Probability of M&#39;</span><span class="p">],</span> <span class="n">flt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;Probability of G1/G2&#39;</span><span class="p">],</span> <span class="n">flt</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">SMOOTH</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">cur_track</span><span class="o">.</span><span class="n">index</span>
                <span class="n">ix</span> <span class="o">=</span> <span class="n">ix</span><span class="p">[</span><span class="n">escape</span><span class="p">:(</span><span class="n">cur_track</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">escape</span><span class="p">)]</span>
                <span class="n">cur_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="s1">&#39;Probability of S&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
                <span class="n">cur_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="s1">&#39;Probability of G1/G2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span>
                <span class="n">cur_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="s1">&#39;Probability of M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cur_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="p">[</span><span class="s1">&#39;Probability of G1/G2&#39;</span><span class="p">,</span> <span class="s1">&#39;Probability of S&#39;</span><span class="p">,</span> <span class="s1">&#39;Probability of M&#39;</span><span class="p">]]),</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">phase</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dic</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">idx</span><span class="p">))</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">cur_track</span><span class="p">[</span><span class="s1">&#39;predicted_class&#39;</span><span class="p">])</span>
                <span class="n">cur_track</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="s1">&#39;predicted_class&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase</span>

            <span class="n">track_filtered</span> <span class="o">=</span> <span class="n">track_filtered</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_track</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Object classification corrected by smoothing: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">track_filtered</span></div>

<div class="viewcode-block" id="Refiner.getMeanDisplace"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.getMeanDisplace">[docs]</a>    <span class="k">def</span> <span class="nf">getMeanDisplace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate mean displace of each track normalized with frame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;trackId&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;mean_displace&#39;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]):</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sub</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">frame_diff</span> <span class="o">=</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">sub</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># normalize with frame</span>
                <span class="n">dp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_diff</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dp</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;mean_displace&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dp</span><span class="p">))</span>
                <span class="n">d</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>

<div class="viewcode-block" id="Refiner.getAsoInput"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.getAsoInput">[docs]</a>    <span class="k">def</span> <span class="nf">getAsoInput</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">daughter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate SVM classifier input for track 1 &amp; 2.</span>

<span class="sd">        Args:</span>
<span class="sd">            parent (int): parent track ID.</span>
<span class="sd">            daughter (int): daughter track ID.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Input vector of the classifier:</span>
<span class="sd">            - [distance_diff, frame_diff]</span>

<span class="sd">            Some parameters are normalized with dataset specific features:</span>
<span class="sd">            - distance_diff /= ave_displace</span>
<span class="sd">            - frame_diff /= sample_freq</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">parent</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span>
        <span class="n">daug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">daughter</span><span class="p">]</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;frame&#39;</span><span class="p">)</span>

        <span class="c1"># Feature 2: mitosis frame difference</span>
        <span class="c1"># For secondary mitosis, skip the frame before mitosis exit</span>
        <span class="n">m_entry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMtransition</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;entry&#39;</span><span class="p">)</span>
        <span class="n">m_exit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getMtransition</span><span class="p">(</span><span class="n">daughter</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;exit&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m_entry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m_entry</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mt_entry_lookup</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_entry</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># 0: imprecise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mt_entry_lookup</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 1: precise</span>
        <span class="k">if</span> <span class="n">m_exit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m_exit</span> <span class="o">=</span> <span class="n">daug</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span><span class="p">[</span><span class="n">daughter</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_exit</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mt_exit_lookup</span><span class="p">[</span><span class="n">daughter</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_exit</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m_entry</span> <span class="o">&gt;=</span> <span class="n">daug</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># mitosis daughter should appear after NEBD of parent, set -1 to be filtered out in extract_feature() method</span>
            <span class="n">frame_diff</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame_diff</span> <span class="o">=</span> <span class="n">daug</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;frame&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Feature 1: distance</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">par</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">daug</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_0&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">daug</span><span class="p">[</span><span class="s1">&#39;Center_of_the_object_1&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distance_diff</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">distance_diff</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_size</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">frame_diff</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">metaData</span><span class="p">[</span><span class="s1">&#39;meanDisplace&#39;</span><span class="p">]),</span>
               <span class="n">frame_diff</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">metaData</span><span class="p">[</span><span class="s1">&#39;sample_freq&#39;</span><span class="p">]]</span>

        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Refiner.get_SVM_train"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.get_SVM_train">[docs]</a>    <span class="k">def</span> <span class="nf">get_SVM_train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save training data for SVM classifier of this particular dataset.</span>

<span class="sd">        Args:</span>
<span class="sd">            sample (numpy.ndarray): Optional matrix of shape (sample, (parent ID, daughter ID, ...)). If not supplied,</span>
<span class="sd">                will generate directly from mitosis-broken tracked object table. (GT with mitosis relationship)</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray): Input feature map.</span>
<span class="sd">            (numpy.ndarray): Ground truth label.</span>
<span class="sd">            (numpy.ndarray): Track ID of the corresponding feature (row).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Before extracting SVM training data, call doTrackRefine() first.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating SVM samples from mitosis-broken tracked object table.&#39;</span><span class="p">)</span>
            <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]):</span>
                <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">[</span><span class="s1">&#39;trackId&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">][</span><span class="s1">&#39;parentTrackId&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">par</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ct</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">dic</span><span class="p">[</span><span class="n">par</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dic</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; samples drawn from tracked object table.&#39;</span><span class="p">)</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;par&#39;</span><span class="p">:[],</span> <span class="s1">&#39;daug&#39;</span><span class="p">:[]}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;daug&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">sp</span><span class="p">[</span><span class="s1">&#39;par&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating SVM samples from mitosis lookup table.&#39;</span><span class="p">)</span>

        <span class="n">parent_pool</span><span class="p">,</span> <span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_pools</span><span class="p">(</span><span class="n">extra_par</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">extra_daug</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">ipts</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_features</span><span class="p">(</span><span class="n">parent_pool</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">sample</span><span class="o">=</span><span class="n">sample</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ipts</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sample_id</span></div>

<div class="viewcode-block" id="Refiner.setSVMpath"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.setSVMpath">[docs]</a>    <span class="k">def</span> <span class="nf">setSVMpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model_train</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">SVM_PATH</span> <span class="o">=</span> <span class="n">model_train</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="Refiner.doTrackRefine"><a class="viewcode-back" href="../../modules/pcnaDeep.html#pcnaDeep.refiner.Refiner.doTrackRefine">[docs]</a>    <span class="k">def</span> <span class="nf">doTrackRefine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform track refinement process</span>

<span class="sd">        Returns:</span>
<span class="sd">            If run in TRH/SVM mode, will return annotation table, tracked object table and mitosis directory.</span>
<span class="sd">            If run in TRAIN mode, will only return tracked object table after smoothing, mitosis breaking.</span>
<span class="sd">            for manual inspection. After determining the training instance, generate training data through.</span>
<span class="sd">            get_SVM_train(sample).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flag</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Do not call track refine object twice!&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">!=</span> <span class="s1">&#39;TRAIN_GT&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_track</span><span class="p">()</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Level &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; mitosis:&#39;</span><span class="p">)</span>
                <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">break_mitosis</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imprecise</span> <span class="o">=</span> <span class="n">get_rsv_input_gt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="s1">&#39;predicted_class&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">short_tracks</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">register_track</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">==</span> <span class="s1">&#39;TRAIN_GT&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_SVM_train</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">==</span> <span class="s1">&#39;TRH&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">associate</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;TRH&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">==</span> <span class="s1">&#39;SVM&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SVM_PATH</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Path to SVM training data has not set yet, use setSVMpath() to supply an SVM model.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">associate</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">MODE</span> <span class="o">==</span> <span class="s1">&#39;TRAIN&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">track</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_table_with_mt</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ann</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mt_dic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imprecise</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Chan Kuan Yoow Group.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>